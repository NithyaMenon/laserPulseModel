function out = minFun(x,idealTimes,repRate,compositeDelays)
% calculates a quantity for minimization via fmincon for the purpose of
% optimizing a set of digital delays
%
% All times are in nanoseconds.
%
% Inputs:
%  x - input from fmincon, containing the fractions of the repetition rate
%      at which the digital pulses will arrive, mod rep rate
%  idealTimes - the theoretically ideal pulse arrival times
%  repRate - the repetition time of the laser
%  compositeDelays - handle of function to construct the set of usable
%                    delays from the set of tunable delays
%  
%
% Outputs:
%  The function computes the sum of the squared time differences between
%  each ideal pulse and its nearest digital pulse. This function is
%  intended to be used as the input for a call to fmincon, which will
%  optimize the choice of digital arrival times.

% relative weights of switching function to mean-squared errors
relWT = 10;

modTimes = mod(idealTimes,repRate);

% construct the possible delay lines in subfunction; add preceding and
% succeeding pulses as well for wraparound boundary conditions
digTimes = repRate*compositeDelays(x);
perShift = repRate*ones(length(digTimes),1); % time of one repetition of laser
allTimes = [digTimes; digTimes+perShift; digTimes-perShift];

% here we find the nearest pulse, either in this set of digital pulses or an
% adjacent one, for each real pulse
nearPulses = dsearchn(allTimes,modTimes);

% sum individual MSDs
errs = allTimes(nearPulses,1) - modTimes(nearPulses,1);
out = errs'.*errs + relWT*((-1).^([0:length(errs)-1])*errs);
